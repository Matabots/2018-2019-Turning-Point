#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in8,    Potent,         sensorPotentiometer)
#pragma config(Sensor, dgtl5,  LimL1,          sensorTouch)
#pragma config(Sensor, dgtl6,  LimR1,          sensorTouch)
#pragma config(Sensor, dgtl11, stackEnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl9, REnc,       sensorQuadEncoder)
#pragma config(Sensor, dgtl7, LEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           CMot,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LMots1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LMots2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LMots3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           MobMots1,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RMots1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RMots2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RMots3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           MobMots2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LiftMot,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//3s are middles
int n =  1;
float minS;
float target;
float enc = 0;
float error;	//error is the difference between the goal and current distance
float tolerance;	//how accurate do I want the robot to be
float Kp;		//Kp is a multiplier to calibrate the power
float totalError;
float ki;
#include "DriveControls.h"
void resetEnc()
{
	SensorValue[stackEnc] = 0;
}
void MoveArm(float input)
{
	minS = 5;
	target = input;
	error = target - enc;	//error is the difference between the goal and current distance

	tolerance = .25;	//how accurate do I want the robot to be

	Kp = 0.75;		//Kp is a multiplier to calibrate the power

	totalError = 0;
	ki = 0;

	float prevError = 0;
	float kD = 50;
	time1[T1] = 0;

	while(abs(error) > tolerance || time1[T1] > 1000)
		{
			enc = (SensorValue[stackEnc]);
			error = target - enc;
			float motSpeed = -((error * Kp) + (totalError * ki) + (error - prevError)*kD);//constantly updates as I get closer to target

			if (abs(motSpeed) < minS)
			{
			  motor[LiftMot] = minS;
			}
		  else
			{
		    motor[LiftMot] = motSpeed;
		  }
			if(abs(error) < tolerance*50)
			{
					//kD = 20;
				//	ki = 1;
			}
			if(abs(error)>tolerance){

		 		time1[T1] = 0;
			}
				//motor power limits itself to 127 if too large.
				//check to make sure the robot is not stalling before it reaches the target point
					//Note: stalling is either from Kp being too low and doesn't have enough power to push last bit of distance
					//Note: You can eliminate stalling with a minimum speed limit i.e: if(error*kp < MIN){ motor[port[1]] = MIN};

				//*****STEPS TO CALIBRATE Kp*****
				//1. keep increasing Kp until the robot starts to oscillate about the target point physically
				//2. once Kp oscillates, decrease Kp a little so it is stable
		  totalError += error;
		  prevError = error;
		}
	  //}

		//Things to know about P Controllers
		//

}

task main()
{
	setupController();
	resetEnc();

		runController();
		//if (vexRT[controller.stack] == 1)
		//{
			//rotatate for  degrees using P control
		  motor[CMot] = 127;
	    wait10Msec(50);
	    motor[CMot] = 20;
	    wait10Msec(100);

	    MoveArm(230);


	    motor[CMot] = -127;
	    wait10Msec(50);
	    motor[CMot] = 0;
	    wait10Msec(100);

			MoveArm(15);

}
