#pragma config(UART_Usage, UART1, uartUserControl, baudRate9600, IOPins, None, None)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port1,           CMot,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RMots1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RMots2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RMots3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           MobMots1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LMots1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LMots2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LMots3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           MobMots2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LiftMot,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task UARTReceive();

#define bytemax 1
#define deadzone 20
#define XC_BUFFER_SIZE 5
#define PIXY_BUFFER_SIZE 5
#define SONAR_BUFFER_SIZE 10
#define MAXPOWER 127
#define MIN_DISTANCE 100
#define TURNVALUE_HIGH 50
#define TURNVALUE_LOW 35
#define NOPOWER 0
int XC;
int XC_AVG_INDEX;
int XC_AVG_BUFFER[XC_BUFFER_SIZE];
int Pixy_Char;
int PIXY_AVG_INDEX;
int PIXY_AVG_BUFFER[PIXY_BUFFER_SIZE];
int SONAR_VALUE;
int SONAR_AVG_INDEX;
int SONAR_BUFFER[SONAR_BUFFER_SIZE];
int curr_pixy;
short data[bytemax];

int byteCheck(char c){
    if(c >= 48 && c <= 53)
    	return 1;
   else
     return 0;
}

void stopAllMotors(){
	 motor[LMots1] = NOPOWER;
	 motor[LMots2] = NOPOWER;
	 motor[LMots3] = NOPOWER;
	 motor[RMots1] = NOPOWER;
	 motor[RMots2] = NOPOWER;
	 motor[RMots3] = NOPOWER;
	 motor[LiftMot] = NOPOWER;
}

void moveUP(){
    clearTimer(T1);
    int stopTime = time1[T1] + 10000;

	while(XC == 2 && XC != 5 && time1[T1] <= stopTime && SONAR_VALUE < MIN_DISTANCE){
		//Set values to maxpower
	}

	stopAllMotors();
}

void rotateLeft(int corner){

	//rotate left

  if(corner == 1){
  	motor[LMots1] = TURNVALUE_HIGH;
  	motor[LMots2] = TURNVALUE_HIGH;
  	motor[LMots3] = TURNVALUE_HIGH;
  	motor[RMots1] = -TURNVALUE_HIGH;
  	motor[RMots2] = -TURNVALUE_HIGH;
  	motor[RMots3] = -TURNVALUE_HIGH;
  }
  else if(corner == 0){
  	motor[LMots1] = TURNVALUE_LOW;
  	motor[LMots2] = TURNVALUE_LOW;
  	motor[LMots3] = TURNVALUE_LOW;
  	motor[RMots1] = -TURNVALUE_LOW;
  	motor[RMots2] = -TURNVALUE_LOW;
  	motor[RMots3] = -TURNVALUE_LOW;
  }
	wait1Msec(500);
	stopAllMotors();
}

void rotateLeft_Adv(){
 clearTimer(T1);

 int stopTime = time1[T1] + 2000;

 while(XC != 2 && time1[T1] < stopTime){
    motor[LMots1] = TURNVALUE_LOW;
  	motor[LMots2] = TURNVALUE_LOW;
  	motor[LMots3] = TURNVALUE_LOW;
  	motor[RMots1] = -TURNVALUE_LOW;
  	motor[RMots2] = -TURNVALUE_LOW;
  	motor[RMots3] = -TURNVALUE_LOW;

  }

  stopAllMotors();
  wait10Msec(50);
}

void rotateRight_Adv(){
 clearTimer(T1);

 int stopTime = time1[T1] + 2000;

 while(XC != 2 && time1[T1] < stopTime){
    motor[LMots1] = -TURNVALUE_LOW;
  	motor[LMots2] = -TURNVALUE_LOW;
  	motor[LMots3] = -TURNVALUE_LOW;
  	motor[RMots1] = TURNVALUE_LOW;
  	motor[RMots2] = TURNVALUE_LOW;
  	motor[RMots3] = TURNVALUE_LOW;

  }

  stopAllMotors();
  wait10Msec(50);
}
void rotateRight(int corner){

	//rotate right
  if(corner == 1){
  	motor[LMots1] = -TURNVALUE_HIGH;
  	motor[LMots2] = -TURNVALUE_HIGH;
  	motor[LMots3] = -TURNVALUE_HIGH;
  	motor[RMots1] = TURNVALUE_HIGH;
  	motor[RMots2] = TURNVALUE_HIGH;
  	motor[RMots3] = TURNVALUE_HIGH;
  }
  else if(corner == 0){
  	motor[LMots1] = -TURNVALUE_LOW;
  	motor[LMots2] = -TURNVALUE_LOW;
  	motor[LMots3] = -TURNVALUE_LOW;
  	motor[RMots1] = TURNVALUE_LOW;
  	motor[RMots2] = TURNVALUE_LOW;
  	motor[RMots3] = TURNVALUE_LOW;
  }
	wait1Msec(500);
	stopAllMotors();
}

int getAverage(int *values,int size){

	int avg = 0;
	int i = 0;

	for(i = 0; i < size; i++)
		avg += values[i];

	avg = avg/size;
	return avg;
}

task UARTReceive(){

    XC_AVG_INDEX = 0;
    PIXY_AVG_INDEX = 0;
	while(true){

     Pixy_Char = getChar(uartOne);


     //if(Pixy_Char == -1 || Pixy_Char == NULL){
       //  wait1Msec(2);
         //continue;
     //}

    if(byteCheck(Pixy_Char) == 1){
       XC = Pixy_Char - 48;
	  // XC_AVG_BUFFER[XC_AVG_INDEX] = Pixy_Char - 48;
	//   XC_AVG_INDEX++;

	  // if(XC_AVG_INDEX == XC_BUFFER_SIZE)
	//	   XC_AVG_INDEX = 0;

     //  XC = getAverage(XC_AVG_BUFFER,XC_BUFFER_SIZE);
	  }

	}
}


task SensorReader(){
	int SONAR_AVG_INDEX = 0;

	while(true){

		SONAR_BUFFER[SONAR_AVG_INDEX] = SensorValue[sonar];
		SONAR_AVG_INDEX++;

		if(SONAR_AVG_INDEX == SONAR_BUFFER_SIZE)
			SONAR_AVG_INDEX = 0;

		SONAR_VALUE = getAverage(SONAR_BUFFER,SONAR_BUFFER_SIZE);
	}
}

task Drive(){
	int leftStick;
	int rightStick;

   while(true){
     leftStick = vexRT[Ch3];
     rightStick = vexRT[Ch2];

     if(abs(leftStick) < deadzone)
        leftStick = 0;
     if(abs(rightStick) < deadzone)
        rightStick = 0;

     motor[LMots1] = leftStick;
     motor[LMots2] = leftStick;
     motor[LMots3] = leftStick;
     motor[RMots1] = rightStick;
     motor[RMots2] = rightStick;
     motor[RMots3] = rightStick;


   }

}

task FollowRoutine(){

    while(true){
		//If Cone is not there

    if(XC == -1 || XC == 5)
    	continue;
   //If the cone is to the left
	 else if(XC == 0){
			rotateRight_Adv();
			XC = 5;
	 }
	  else if(XC == 1){
	  	rotateRight_Adv();
	    XC = 5;
	  }
		//If Cone is in the front
	//	else if(XC == 2)
		//	moveUP();
		//If Cone is to the right
		else if(XC == 3){
			rotateLeft_Adv();
		  XC = 5;
		}
	  else if(XC == 4){
			rotateLeft_Adv();
			XC = 5;
	  }
		wait1Msec(200);
	}
}

task ToggleFollow(){
	 int t_switch = 1;
   while(true){
      if(vexRT[Btn7U] == 1 && t_switch == 1){
      	startTask(Drive);
         stopTask(FollowRoutine);
         t_switch = 0;
         wait1Msec(500);
      }
       if(vexRT[Btn7U] == 1 && t_switch == 0){
         stopTask(Drive);
         startTask(FollowRoutine);
         t_switch = 1;
         wait1Msec(500);
      }
  }

}

task main(){


startTask(UARTReceive);
startTask(SensorReader);
startTask(ToggleFollow);
startTask(FollowRoutine);
//startTask(Drive);
while(true){}

}
