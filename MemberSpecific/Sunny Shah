const int diameter = 4; // inches
const int tile_length = 24; // inches
const float pi = 22 / 7;    // 3.14159...
const float circumference = (pi * diameter);     // the total distance one full rotation of the wheel covers (inches)
const float rotations_per_tile = (tile_length / circumference);    // the number of rotations the wheel makes to cover one tile

float degToInch(int degree)
{
    float inch = ((4 * pi) * (degree/360));
    return inch;
}

void move(float distance)
{
    SensorValue[Encoder] = 0;
    float target = (distance);    // desired distance
    float current = degToInch(SensorValue[Encoder]);    // current distance
    float error = target - current;        // difference between desired distance and current distance
    int weight = 15;
    int tolerance = 1;    // inches
    int MinPower = 25;    // Minimum power for Motor
    int power = error * weight;    // power of motor
    while((current <= (target - tolerance) || current >= (target + tolerance)))
    {
        current = degToInch(SensorValue[Encoder]);
        error = target - current;
        power = error * weight;
        if(abs(power) < MinPower)
        {
            if(power > 0)
            {
                motor[RMotor] = MinPower;
                motor[LMotor] = MinPower;
            }
            else if (power < 0)
            {
                motor[RMotor] = -MinPower;
                motor[LMotor] = -MinPower;
            }
        }
        else
        {
            motor[RMotor] = power;
            motor[LMotor] = power;
        }
    }
    motor[RMotor] = 0;
    motor[LMotor] = 0;
    SensorValue[Encoder] = 0;

}

void turn(int NumofDegrees)
{
    SensorValue[Encoder] = 0;
    const float radius_of_robot = 5.5;            // this is the length from the center of the robot to the wheel (in inches)
    const float RobotCircumference = (2 * pi * radius_of_robot);    // this is the circumference of the circle that would be made by a turning robot
    float target = (RobotCircumference / 360) * NumofDegrees;
    float current = degToInch(SensorValue[Encoder]);
    float error = target - current;
    const int weight = 5;
    const float tolerance = 3.8;    // inches
    const int MinPower = 18;    // Minimum power for Motor
    int power = error * weight;
    while((current) <= (target - tolerance) || (current) >= (target + tolerance))
    {
        current = degToInch(SensorValue[Encoder]);
        error = target - current;
        power = error * weight;
        if(abs(power) < MinPower)
        {
            if(power > 0)
            {
                motor[RMotor] = -MinPower;
                motor[LMotor] = MinPower;
            }
            else if (power < 0)
            {
                motor[RMotor] = MinPower;
                motor[LMotor] = -MinPower;
            }
        }
        else
        {
            motor[RMotor] = -power;
            motor[LMotor] = power;
        }
    }
    motor[RMotor] = 0;
    motor[LMotor] = 0;
    SensorValue[Encoder] = 0;

}

void faceDirection(int DirectionFacing, int GoalDirection)
{
    // N = 1, E = 2, S = 3, W = 4
    int DirectionToTurn = DirectionFacing - GoalDirection;
    switch(DirectionToTurn)
    {
    case 1:
    case -3:
        turn(-90);
        break;
    case -1:
    case 3:
        turn(90);
        break;
    case 2:
    case -2:
        turn(180);
        break;
    default:
        break;
    }
}
